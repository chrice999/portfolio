<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur d'Histoires et D√©bats d'IA</title>
    <style>
        :root {
            --bg-color: #121212; --card-bg: #1e1e1e; --text-color: #e0e0e0;
            --primary-color: #bb86fc; --border-color: #333; --shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
        }
        html, body { height: 100%; margin: 0; overflow: hidden; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            display: flex;
        }
        #sidebar {
            width: 250px; background-color: #181818; padding: 20px;
            display: flex; flex-direction: column; border-right: 1px solid var(--border-color);
            transition: transform 0.3s ease; box-sizing: border-box;
        }
        #sidebar h2 { color: var(--primary-color); margin-top: 0; }
        #saved-simulations { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #saved-simulations li {
            padding: 10px; margin-bottom: 10px; border-radius: 8px; cursor: pointer;
            background-color: #2c2c2c; transition: background-color 0.3s; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis; display: flex; justify-content: space-between; align-items: center;
        }
        #saved-simulations li:hover, #saved-simulations li.active { background-color: var(--primary-color); color: #000; }
        .delete-sim-btn { background: none; border: none; color: #999; cursor: pointer; font-size: 18px; }
        .delete-sim-btn:hover { color: #ff6b6b; }
        #new-sim-btn {
            padding: 12px; background-color: var(--primary-color); color: #000; border: none;
            border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 20px;
        }
        .main-content { flex-grow: 1; display: flex; justify-content: center; align-items: center; padding: 10px; height: 100vh; box-sizing: border-box; }
        .container {
            width: 100%; height: 100%; max-width: 800px; background: var(--card-bg);
            border-radius: 12px; box-shadow: var(--shadow);
            border: 1px solid var(--border-color); display: flex; flex-direction: column;
        }
        .setup-screen { padding: 20px; overflow-y: auto; flex-grow: 1; }
        .debate-screen { padding: 20px; overflow-y: auto; flex-grow: 1; display: flex; flex-direction: column; }
        h1, h2 { text-align: center; color: var(--primary-color); margin-bottom: 20px; }
        .input-group { margin-bottom: 20px; }
        .input-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #b0b0b0; }
        .input-group input, .input-group select, .input-group textarea {
            width: 100%; padding: 12px; border: 1px solid var(--border-color);
            background-color: #2c2c2c; color: var(--text-color); border-radius: 8px;
            font-size: 16px; box-sizing: border-box; font-family: inherit;
        }
        .btn {
            display: block; width: 100%; padding: 14px; background-color: var(--primary-color);
            color: #000; border: none; border-radius: 8px; font-size: 18px;
            font-weight: bold; cursor: pointer; transition: background-color 0.3s;
        }
        #conversation { margin-top: 20px; overflow-y: auto; padding-right: 15px; flex-grow: 1; }
        .message {
            margin-bottom: 15px; padding: 12px; border-radius: 18px; line-height: 1.4;
            display: flex; align-items: flex-start; background-color: #2c2c2c;
            opacity: 0; transform: translateY(20px); animation: fadeIn 0.5s forwards;
        }
        .narrator { background-color: transparent; border: 1px dashed #666; font-style: italic; color: #aaa; }
        .user-choice { background-color: rgba(187, 134, 252, 0.2); position: relative; }
        .chapter-break {
            background-color: transparent; text-align: center; font-weight: bold;
            color: var(--primary-color); margin: 25px 0;
        }
        .rewind-btn {
            position: absolute; top: 5px; right: 10px; background: none; border: none;
            color: #aaa; cursor: pointer; font-size: 18px;
        }
        .rewind-btn:hover { color: var(--primary-color); }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        .message .icon { font-size: 24px; margin-right: 12px; }
        .message .content { flex: 1; }
        .message strong { display: block; margin-bottom: 4px; color: var(--primary-color); }
        .message p { margin: 0; white-space: pre-wrap; }
        .final-summary { background-color: rgba(187, 134, 252, 0.1); padding: 20px; border: 1px solid var(--primary-color); border-radius: 8px; margin-top: 20px;}
        #loader { text-align: center; padding: 20px; display: none; }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: var(--primary-color);
            animation: spin 1s ease infinite; margin: auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #error-message { color: #cf6679; text-align: center; margin-top: 10px; display: none; }
        .hidden { display: none; }
        #choices-container {
            flex-shrink: 0;
            padding: 20px 0;
            margin-bottom: 60px; /* Espace pour la navigation gestuelle */
        }
        .choices-wrapper {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;
        }
        .choice-btn {
            padding: 10px 15px; background-color: #2c2c2c; border: 1px solid var(--primary-color);
            color: var(--primary-color); border-radius: 20px; cursor: pointer;
        }
        #custom-action-container { display: flex; gap: 10px; width: 100%; margin-top: 10px; }
        #custom-action-input { flex-grow: 1; }
        #sidebar-toggle {
            display: none; position: fixed; top: 10px; left: 10px; z-index: 1000;
            background: var(--primary-color); color: #000; border: none; border-radius: 50%;
            width: 40px; height: 40px; font-size: 24px; cursor: pointer;
        }
        @media (max-width: 768px) {
            #sidebar { position: fixed; transform: translateX(-100%); z-index: 999; height: 100%; }
            #sidebar.open { transform: translateX(0); }
            #sidebar-toggle { display: block; }
            .main-content { padding: 10px; }
        }
    </style>
</head>
<body>
    <button id="sidebar-toggle">‚ò∞</button>
    <div id="sidebar">
        <h2 id="sidebar-title"></h2>
        <ul id="saved-simulations"></ul>
        <button id="new-sim-btn"></button>
        <div class="input-group" style="margin-top: auto;">
            <label for="language-switcher" id="language-label"></label>
            <select id="language-switcher">
                <option value="fr">Fran√ßais</option>
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <option value="zh">‰∏≠Êñá</option>
            </select>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <div class="setup-screen" id="setupScreen">
                <h1 id="setup-title"></h1>
                <p id="setup-subtitle" style="text-align:center; color: #b0b0b0;"></p>
                <div class="input-group">
                    <label for="topic" id="topic-label"></label>
                    <input type="text" id="topic">
                </div>
                <div class="input-group">
                    <label for="simulationMode" id="mode-label"></label>
                    <select id="simulationMode">
                        <option value="debate" id="mode-debate"></option>
                        <option value="acting" id="mode-acting"></option>
                        <option value="narrator" id="mode-narrator"></option>
                        <option value="create_char" id="mode-create_char"></option>
                        <option value="dreame" id="mode-dreame"></option>
                    </select>
                </div>
                <div id="custom-char-group" class="input-group hidden">
                    <label for="custom-char-name" id="char-name-label"></label>
                    <input type="text" id="custom-char-name">
                    <label for="custom-char-gender" style="margin-top:10px;" id="char-gender-label"></label>
                    <select id="custom-char-gender">
                        <option value="Fille" id="gender-female"></option>
                        <option value="Gar√ßon" id="gender-male"></option>
                    </select>
                    <label for="custom-char-desc" style="margin-top:10px;" id="char-desc-label"></label>
                    <textarea id="custom-char-desc" rows="3"></textarea>
                </div>
                 <div id="dreame-options-group" class="input-group hidden">
                    <label for="num-chapters" id="chapters-label"></label>
                    <input type="number" id="num-chapters" value="5" min="1" max="20">
                    <label style="margin-top:10px;"><input type="checkbox" id="dreame-omni"> <span id="omni-label"></span></label>
                </div>
                <div class="input-group" id="num-ias-group">
                    <label for="numIAs" id="participants-label"></label>
                    <input type="number" id="numIAs" value="4" min="2" max="6">
                </div>
                <button class="btn" id="startButton"></button>
                <p id="error-message"></p>
            </div>

            <div class="debate-screen hidden" id="debateScreen">
                <h2 id="debateTitle"></h2>
                <div id="conversation"></div>
                <div id="choices-container"></div>
                <div id="loader">
                    <div class="spinner"></div>
                    <p id="loader-text"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const geminiApiKey = "AIzaSyCStPfglyB9axkx3cUYkLfrdRcQlzBYIAc";
        let savedSimulations = [];
        let currentSim = null;
        let isTyping = false;
        let currentLanguage = 'fr';

        const NARRATOR_PROFILE = { name: "Narrateur", role: "Omniscient", icon: "üìñ" };
        const USER_PROFILE = { name: "Toi", role: "Protagoniste", icon: "üë§" };
        const CHAPTER_PROFILE = { name: "Chapitre", role: "Progression", icon: "üîñ" };

        const translations = {
            fr: {
                langCode: "fran√ßais",
                sidebarTitle: "Mes Simulations",
                newSimButton: "Nouvelle Simulation",
                languageLabel: "Langue",
                setupTitle: "Nouvelle Simulation",
                setupSubtitle: "L'IA cr√©e les participants en fonction de votre sujet.",
                topicLabel: "Sujet (ou laissez vide pour un titre surprise)",
                topicPlaceholder: "Ex: Romance avec un Alpha myst√©rieux",
                modeLabel: "Mode de Simulation",
                modeDebate: "D√©bat Classique",
                modeActing: "Jeu d'acteur",
                modeNarrator: "D√©bat avec Narrateur",
                modeCreateChar: "Cr√©ation Personnage",
                modeDreame: "Histoire Interactive (Dreame)",
                charNameLabel: "Nom de ton Personnage",
                charNamePlaceholder: "Laissez vide pour le mode spectateur",
                charGenderLabel: "Sexe",
                genderFemale: "Fille",
                genderMale: "Gar√ßon",
                charDescLabel: "Description",
                charDescPlaceholder: "Ex: Timide mais courageuse...",
                chaptersLabel: "Chapitre",
                omniLabel: "Vue Omnisciente",
                participantsLabel: "Nombre de Participants IA (2-6)",
                startButton: "Lancer la Simulation",
                loaderText: "IA en cours de r√©flexion...",
                errorTopic: "Veuillez fournir un sujet.",
                errorParticipants: "L'IA n'a pas pu cr√©er les participants.",
                conclusionTitle: "Conclusion",
                conclusionSystem: "Syst√®me",
                historyEnded: "Cette histoire est termin√©e.",
                youAre: "Tu incarnes",
                spectatorMode: "Mode spectateur activ√©. L'histoire se d√©roule...",
                unexpectedEnd: "L'histoire semble √™tre arriv√©e √† une fin inattendue.",
                customActionPlaceholder: "Ou √©cris ta propre action...",
                sendButton: "Envoyer"
            },
            en: {
                langCode: "english",
                sidebarTitle: "My Simulations",
                newSimButton: "New Simulation",
                languageLabel: "Language",
                setupTitle: "New Simulation",
                setupSubtitle: "The AI creates participants based on your topic.",
                topicLabel: "Topic (or leave blank for a surprise title)",
                topicPlaceholder: "E.g., Romance with a mysterious Alpha",
                modeLabel: "Simulation Mode",
                modeDebate: "Classic Debate",
                modeActing: "Role-playing Scene",
                modeNarrator: "Debate with Narrator",
                modeCreateChar: "Character Creation",
                modeDreame: "Interactive Story (Dreame)",
                charNameLabel: "Your Character's Name",
                charNamePlaceholder: "Leave blank for spectator mode",
                charGenderLabel: "Gender",
                genderFemale: "Girl",
                genderMale: "Boy",
                charDescLabel: "Description",
                charDescPlaceholder: "E.g., Shy but brave, with a secret past...",
                chaptersLabel: "Chapter",
                omniLabel: "Omniscient View",
                participantsLabel: "Number of AI Participants (2-6)",
                startButton: "Start Simulation",
                loaderText: "AI is thinking...",
                errorTopic: "Please provide a topic.",
                errorParticipants: "The AI could not create the participants.",
                conclusionTitle: "Conclusion",
                conclusionSystem: "System",
                historyEnded: "This story has ended.",
                youAre: "You are playing as",
                spectatorMode: "Spectator mode activated. The story unfolds...",
                unexpectedEnd: "The story seems to have reached an unexpected end.",
                customActionPlaceholder: "Or write your own action...",
                sendButton: "Send"
            },
            es: {
                langCode: "espa√±ol",
                sidebarTitle: "Mis Simulaciones",
                newSimButton: "Nueva Simulaci√≥n",
                languageLabel: "Idioma",
                setupTitle: "Nueva Simulaci√≥n",
                setupSubtitle: "La IA crea participantes basados en tu tema.",
                topicLabel: "Tema (o d√©jalo en blanco para un t√≠tulo sorpresa)",
                topicPlaceholder: "Ej: Romance con un Alfa misterioso",
                modeLabel: "Modo de Simulaci√≥n",
                modeDebate: "Debate Cl√°sico",
                modeActing: "Escena de Rol",
                modeNarrator: "Debate con Narrador",
                modeCreateChar: "Creaci√≥n de Personaje",
                modeDreame: "Historia Interactiva (Dreame)",
                charNameLabel: "Nombre de tu Personaje",
                charNamePlaceholder: "Dejar en blanco para modo espectador",
                charGenderLabel: "G√©nero",
                genderFemale: "Chica",
                genderMale: "Chico",
                charDescLabel: "Descripci√≥n",
                charDescPlaceholder: "Ej: T√≠mida pero valiente, con un pasado secreto...",
                chaptersLabel: "Cap√≠tulo",
                omniLabel: "Vista Omnisciente",
                participantsLabel: "N√∫mero de Participantes de IA (2-6)",
                startButton: "Iniciar Simulaci√≥n",
                loaderText: "La IA est√° pensando...",
                errorTopic: "Por favor, proporciona un tema.",
                errorParticipants: "La IA no pudo crear los participantes.",
                conclusionTitle: "Conclusi√≥n",
                conclusionSystem: "Sistema",
                historyEnded: "Esta historia ha terminado.",
                youAre: "Est√°s jugando como",
                spectatorMode: "Modo espectador activado. La historia se desarrolla...",
                unexpectedEnd: "La historia parece haber llegado a un final inesperado.",
                customActionPlaceholder: "O escribe tu propia acci√≥n...",
                sendButton: "Enviar"
            },
            zh: {
                langCode: "‰∏≠Êñá",
                sidebarTitle: "ÊàëÁöÑÊ®°Êãü",
                newSimButton: "Êñ∞ÁöÑÊ®°Êãü",
                languageLabel: "ËØ≠Ë®Ä",
                setupTitle: "Êñ∞ÁöÑÊ®°Êãü",
                setupSubtitle: "AIÊ†πÊçÆÊÇ®ÁöÑ‰∏ªÈ¢òÂàõÂª∫ÂèÇ‰∏éËÄÖ„ÄÇ",
                topicLabel: "‰∏ªÈ¢òÔºàÊàñÁïôÁ©∫‰ª•Ëé∑ÂæóÊÉäÂñúÊ†áÈ¢òÔºâ",
                topicPlaceholder: "‰æãÂ¶ÇÔºö‰∏éÁ•ûÁßòÈòøÂ∞îÊ≥ïÁöÑÊµ™Êº´Âè≤",
                modeLabel: "Ê®°ÊãüÊ®°Âºè",
                modeDebate: "ÁªèÂÖ∏Ëæ©ËÆ∫",
                modeActing: "ËßíËâ≤ÊâÆÊºîÂú∫ÊôØ",
                modeNarrator: "Â∏¶ÂèôËø∞ËÄÖÁöÑËæ©ËÆ∫",
                modeCreateChar: "ËßíËâ≤ÂàõÂª∫",
                modeDreame: "‰∫íÂä®ÊïÖ‰∫ãÔºàDreameÔºâ",
                charNameLabel: "‰Ω†ÁöÑËßíËâ≤ÂêçÂ≠ó",
                charNamePlaceholder: "ÊóÅËßÇËÄÖÊ®°ÂºèËØ∑ÁïôÁ©∫",
                charGenderLabel: "ÊÄßÂà´",
                genderFemale: "Â•≥Â≠©",
                genderMale: "Áî∑Â≠©",
                charDescLabel: "ÊèèËø∞",
                charDescPlaceholder: "‰æãÂ¶ÇÔºöÂÆ≥Áæû‰ΩÜÂãáÊï¢ÔºåÊúâÁùÄÁßòÂØÜÁöÑËøáÂéª...",
                chaptersLabel: "Á´†ËäÇ",
                omniLabel: "ÂÖ®Áü•ËßÜËßí",
                participantsLabel: "AIÂèÇ‰∏éËÄÖ‰∫∫Êï∞Ôºà2-6Ôºâ",
                startButton: "ÂºÄÂßãÊ®°Êãü",
                loaderText: "AIÊ≠£Âú®ÊÄùËÄÉ‰∏≠...",
                errorTopic: "ËØ∑ËæìÂÖ•‰∏Ä‰∏™‰∏ªÈ¢ò„ÄÇ",
                errorParticipants: "AIÊó†Ê≥ïÂàõÂª∫ÂèÇ‰∏éËÄÖ„ÄÇ",
                conclusionTitle: "ÁªìËÆ∫",
                conclusionSystem: "Á≥ªÁªü",
                historyEnded: "Ëøô‰∏™ÊïÖ‰∫ãÂ∑≤ÁªèÁªìÊùü‰∫Ü„ÄÇ",
                youAre: "ÊÇ®ÊâÆÊºîÁöÑÊòØ",
                spectatorMode: "ËßÇÂØüËÄÖÊ®°ÂºèÂ∑≤ÊøÄÊ¥ª„ÄÇÊïÖ‰∫ãÊ≠£Âú®Â±ïÂºÄ...",
                unexpectedEnd: "ÊïÖ‰∫ã‰ºº‰πéÂ∑≤ÁªèËµ∞Âà∞‰∫ÜÊÑèÊÉ≥‰∏çÂà∞ÁöÑÁªìÂ±Ä„ÄÇ",
                customActionPlaceholder: "ÊàñËÄÖÂÜô‰∏ã‰Ω†Ëá™Â∑±ÁöÑË°åÂä®...",
                sendButton: "ÂèëÈÄÅ"
            }
        };

        const dom = {
            sidebar: document.getElementById('sidebar'),
            sidebarToggle: document.getElementById('sidebar-toggle'),
            startButton: document.getElementById('startButton'),
            topicInput: document.getElementById('topic'),
            numIAsInput: document.getElementById('numIAs'),
            numIAsGroup: document.getElementById('num-ias-group'),
            numChaptersInput: document.getElementById('num-chapters'),
            modeInput: document.getElementById('simulationMode'),
            setupScreen: document.getElementById('setupScreen'),
            debateScreen: document.getElementById('debateScreen'),
            conversationDiv: document.getElementById('conversation'),
            loader: document.getElementById('loader'),
            debateTitle: document.getElementById('debateTitle'),
            errorMessage: document.getElementById('error-message'),
            customCharGroup: document.getElementById('custom-char-group'),
            customCharNameInput: document.getElementById('custom-char-name'),
            customCharGenderInput: document.getElementById('custom-char-gender'),
            customCharDescInput: document.getElementById('custom-char-desc'),
            dreameOptionsGroup: document.getElementById('dreame-options-group'),
            dreameOmniCheckbox: document.getElementById('dreame-omni'),
            choicesContainer: document.getElementById('choices-container'),
            savedSimsList: document.getElementById('saved-simulations'),
            newSimBtn: document.getElementById('new-sim-btn'),
            languageSwitcher: document.getElementById('language-switcher'),
        };

        function t(key) {
            return translations[currentLanguage][key] || translations['en'][key];
        }

        function updateUIText() {
            document.documentElement.lang = currentLanguage;
            // Sidebar
            dom.sidebar.querySelector('h2').textContent = t('sidebarTitle');
            dom.newSimBtn.textContent = t('newSimButton');
            document.getElementById('language-label').textContent = t('languageLabel');
            // Setup Screen
            dom.setupScreen.querySelector('h1').textContent = t('setupTitle');
            document.getElementById('setup-subtitle').textContent = t('setupSubtitle');
            document.getElementById('topic-label').textContent = t('topicLabel');
            dom.topicInput.placeholder = t('topicPlaceholder');
            document.getElementById('mode-label').textContent = t('modeLabel');
            document.getElementById('mode-debate').textContent = t('modeDebate');
            document.getElementById('mode-acting').textContent = t('modeActing');
            document.getElementById('mode-narrator').textContent = t('modeNarrator');
            document.getElementById('mode-create_char').textContent = t('modeCreateChar');
            document.getElementById('mode-dreame').textContent = t('modeDreame');
            document.getElementById('char-name-label').textContent = t('charNameLabel');
            dom.customCharNameInput.placeholder = t('charNamePlaceholder');
            document.getElementById('char-gender-label').textContent = t('charGenderLabel');
            document.getElementById('gender-female').textContent = t('genderFemale');
            document.getElementById('gender-male').textContent = t('genderMale');
            document.getElementById('char-desc-label').textContent = t('charDescLabel');
            dom.customCharDescInput.placeholder = t('charDescPlaceholder');
            document.getElementById('chapters-label').textContent = t('chaptersLabel');
            document.getElementById('omni-label').textContent = t('omniLabel');
            document.getElementById('participants-label').textContent = t('participantsLabel');
            dom.startButton.textContent = t('startButton');
            // Debate Screen
            dom.loader.querySelector('p').textContent = t('loaderText');
        }

        function initialize() {
            const savedLang = localStorage.getItem('iaSimLang') || navigator.language.split('-')[0];
            currentLanguage = translations[savedLang] ? savedLang : 'en';
            dom.languageSwitcher.value = currentLanguage;

            loadSimulationsFromStorage();
            renderSimulationsList();
            if (savedSimulations.length > 0) {
                loadSimulation(savedSimulations[0].id);
            } else {
                showSetupScreen();
            }
            updateUIForMode();
            setupEventListeners();
            updateUIText();
        }

        function setupEventListeners() {
            dom.modeInput.addEventListener('change', updateUIForMode);
            dom.newSimBtn.addEventListener('click', () => {
                showSetupScreen();
                dom.sidebar.classList.remove('open'); // Auto-close sidebar on mobile
            });
            dom.startButton.addEventListener('click', startNewSimulation);
            dom.sidebarToggle.addEventListener('click', () => dom.sidebar.classList.toggle('open'));
            dom.languageSwitcher.addEventListener('change', (e) => {
                currentLanguage = e.target.value;
                localStorage.setItem('iaSimLang', currentLanguage);
                updateUIText();
                renderSimulationsList();
            });
        }

        function updateUIForMode() {
            const mode = dom.modeInput.value;
            dom.customCharGroup.classList.toggle('hidden', mode !== 'create_char' && mode !== 'dreame');
            dom.dreameOptionsGroup.classList.toggle('hidden', mode !== 'dreame');
            dom.numIAsGroup.classList.toggle('hidden', mode === 'dreame');
        }

        async function startNewSimulation() {
            let topic = dom.topicInput.value.trim();
            const mode = dom.modeInput.value;
            const numIAs = (mode === 'dreame') ? 3 : parseInt(dom.numIAsInput.value, 10);
            const numChapters = parseInt(dom.numChaptersInput.value, 10);

            dom.errorMessage.style.display = 'none';

            currentSim = {
                id: Date.now(), topic, numIAs, mode, history: [],
                isFinished: false, isSpectator: false, numChapters, generatedTitle: "", lang: currentLanguage
            };

            if (mode === 'create_char' || mode === 'dreame') {
                const charName = dom.customCharNameInput.value.trim();
                if (mode === 'dreame' && !charName) {
                    currentSim.isSpectator = true;
                } else {
                    currentSim.customChar = {
                        name: charName || t('charNamePlaceholder'),
                        gender: dom.customCharGenderInput.value,
                        desc: dom.customCharDescInput.value.trim()
                    };
                }
            }
            if (mode === 'dreame') {
                currentSim.isOmniscient = dom.dreameOmniCheckbox.checked;
            }
            
            savedSimulations.unshift(currentSim);
            
            showDebateScreen();
            await runSimulation();
        }

        async function runSimulation() {
            if (currentSim.history.length > 0) return;

            if (!currentSim.topic && currentSim.mode === 'dreame') {
                const hookPrompt = `Invente un titre de roman accrocheur et myst√©rieux dans le style Dreame (ex: "Mon Alpha ne sera jamais √† moi"). R√©ponds UNIQUEMENT avec le titre, dans la langue suivante: ${t('langCode')}.`;
                currentSim.generatedTitle = await callGeminiAPI(hookPrompt);
            }
            
            const personas = await generatePersonas();
            if (!personas) return;
            currentSim.personas = personas;
            
            saveSimulationsToStorage();
            renderSimulationsList();

            if (currentSim.mode === 'dreame') {
                await runDreameMode();
            } else {
                await runStandardMode();
            }
        }

        async function runDreameMode(startIndex = 0) {
            if (startIndex === 0) {
                const userChar = currentSim.personas.find(p => p.isUser);
                if (userChar) {
                    await addMessageToHistory(USER_PROFILE, `${t('youAre')} ${userChar.name}.`);
                } else {
                     await addMessageToHistory(NARRATOR_PROFILE, t('spectatorMode'));
                }
            }
            
            for (let i = Math.floor(startIndex / (currentSim.isSpectator ? 1 : 2)); i < currentSim.numChapters; i++) {
                if(currentSim.isFinished) break;

                await addMessageToHistory(CHAPTER_PROFILE, `${t('chaptersLabel')} ${i + 1}`);
                
                const historyText = getHistoryAsText();
                let storyPrompt;
                const userChar = currentSim.personas.find(p => p.isUser);

                if (currentSim.isSpectator) {
                    storyPrompt = `Contexte:\n${historyText}\n\nEn tant que ma√Ætre du jeu, continue l'histoire de mani√®re √©pique et √©motionnelle pour ce chapitre. D√©cris la sc√®ne et les actions des personnages. Les actions des personnages doivent √™tre √† la 3√®me personne (ex: "ses joues devinrent rouges", "il tendit la main"). La narration pour ce chapitre ne doit pas d√©passer 100 lignes. R√©ponds en ${t('langCode')}.`;
                } else {
                    storyPrompt = `Contexte:\n${historyText}\n\nContinue l'histoire style 'Dreame' pour ce chapitre (romance, tension, myst√®re, √©motions fortes). D√©cris la sc√®ne, y compris les actions et √©motions entre parenth√®ses (ex: *Il serre les poings*). Les actions des personnages IA doivent √™tre √† la 3√®me personne. Propose 3 choix prenants pour ${userChar.name}. Formatte les choix comme ceci : [CHOIX 1: ...], [CHOIX 2: ...], [CHOIX 3: ...]. La narration pour ce chapitre ne doit pas d√©passer 100 lignes. R√©ponds en ${t('langCode')}.`;
                }

                const storyResponse = await callGeminiAPI(storyPrompt);
                const storyText = storyResponse.split('[CHOIX')[0];
                await addMessageToHistory(NARRATOR_PROFILE, storyText);

                if (!currentSim.isSpectator) {
                    const choices = [...storyResponse.matchAll(/\[CHOIX \d: (.*?)\]/g)].map(m => m[1]);
                    if (choices.length === 0 || storyResponse.includes('[FIN]')) {
                        await finishSimulation(t('unexpectedEnd'));
                        break;
                    }
                    const userChoice = await waitForUserChoice(choices, currentSim.history.length);
                    await addMessageToHistory(USER_PROFILE, userChoice);
                }
            }
            if (!currentSim.isFinished) {
                await finishSimulation(t('historyEnded'));
            }
        }

        async function runStandardMode() {
            for (const profile of currentSim.personas) {
                if (profile.isUser) continue;
                const prompt = `Contexte:\n${getHistoryAsText()}\n\nEn tant que ${profile.name} (${profile.persona}), quelle est ta premi√®re pens√©e ou action concernant le sujet "${currentSim.topic}"? Sois bref. R√©ponds en ${t('langCode')}.`;
                const response = await callGeminiAPI(prompt);
                await addMessageToHistory(profile, response);
            }

            const turns = currentSim.mode === 'acting' ? 3 : 5;
            for (let i = 0; i < turns; i++) {
                if (currentSim.isFinished) break;

                if (currentSim.mode === 'narrator') {
                    const narratorPrompt = `Contexte:\n${getHistoryAsText()}\n\nEn tant que narrateur, d√©cris bri√®vement la sc√®ne ou l'atmosph√®re actuelle en une phrase. R√©ponds en ${t('langCode')}.`;
                    const narratorResponse = await callGeminiAPI(narratorPrompt);
                    await addMessageToHistory(NARRATOR_PROFILE, narratorResponse);
                }
                for (const profile of currentSim.personas) {
                     if (profile.isUser) continue;
                    let prompt = `Contexte:\n${getHistoryAsText()}\n\nC'est ton tour, ${profile.name}. `;
                    if (currentSim.mode === 'acting') {
                        prompt += `En tant que personnage '${profile.persona}', continue la sc√®ne avec une ou deux r√©pliques.`;
                    } else {
                        prompt += `R√©agis √† la discussion en 1-2 phrases.`;
                    }
                    prompt += ` R√©ponds en ${t('langCode')}.`;
                    const response = await callGeminiAPI(prompt);
                    await addMessageToHistory(profile, response);
                }
            }
            if (!currentSim.isFinished) {
                await finishSimulation(t('historyEnded'));
            }
        }
        
        async function generatePersonas() {
            const { topic, numIAs, mode, customChar, isSpectator, generatedTitle } = currentSim;
            const finalTopic = topic || generatedTitle;
            let finalNumIAs = numIAs;
            let userCharPrompt = "";
            if (customChar && !isSpectator) {
                finalNumIAs = (mode === 'dreame') ? numIAs : numIAs - 1;
                userCharPrompt = `L'un des personnages est l'utilisateur : Nom: ${customChar.name}, Sexe: ${customChar.gender}, Description: ${customChar.desc}. Int√®gre-le de mani√®re centrale.`;
            }
            const personaTypes = {
                dreame: `personnages pour une histoire de romance intense style 'Dreame' (loup-garou, alpha, etc). Ils doivent √™tre complexes, avoir leurs propres secrets et ne pas √™tre faciles √† s√©duire.`,
                debate: "d√©batteurs uniques et cr√©atifs aux opinions divergentes",
                acting: "personnages pour une courte sc√®ne de th√©√¢tre",
                narrator: "d√©batteurs avec des personnalit√©s tr√®s marqu√©es et un style de parole distinct",
                create_char: "participants divers pour une discussion"
            };
            const personaDescription = personaTypes[mode] || "participants";

            const prompt = `Cr√©e ${finalNumIAs} profils de ${personaDescription} pour une simulation sur "${finalTopic}". ${userCharPrompt}
IMPORTANT: Ta r√©ponse DOIT √™tre uniquement un objet JSON valide, sans texte d'introduction, explications ou formatage markdown. La structure doit √™tre une liste de ${finalNumIAs} objets.
Chaque objet doit avoir les cl√©s "name", "role", "icon" (un emoji), et "persona". R√©ponds en ${t('langCode')}.`;
            
            const responseText = await callGeminiAPI(prompt);
            try {
                let jsonString = responseText;
                const markdownMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                if (markdownMatch && markdownMatch[1]) {
                    jsonString = markdownMatch[1];
                } else {
                    const startIndex = responseText.indexOf('[');
                    const endIndex = responseText.lastIndexOf(']');
                    if (startIndex !== -1 && endIndex !== -1) {
                        jsonString = responseText.substring(startIndex, endIndex + 1);
                    } else {
                        throw new Error("Aucun tableau JSON trouv√© dans la r√©ponse de l'IA.");
                    }
                }

                let personas = JSON.parse(jsonString);
                if (customChar && !isSpectator) {
                    const userPersona = { name: customChar.name, role: "Protagoniste", icon: "üë§", persona: customChar.desc, isUser: true };
                    personas.push(userPersona);
                }
                return personas;
            } catch (e) {
                console.error("Erreur de parsing JSON:", e, "R√©ponse brute:", responseText);
                dom.errorMessage.textContent = t('errorParticipants');
                dom.errorMessage.style.display = 'block';
                showSetupScreen();
                return null;
            }
        }

        async function addMessageToHistory(profile, text, index = -1) {
            while (isTyping) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            const message = { profile, text };
            if (index === -1) {
                currentSim.history.push(message);
            } else {
                currentSim.history.splice(index, currentSim.history.length - index, message);
            }
            await displayMessage(message, currentSim.history.length - 1);
            saveSimulationsToStorage();
        }

        async function finishSimulation(conclusionText) {
            if (currentSim.isFinished) return;
            currentSim.isFinished = true;
            const finalPrompt = `La simulation est termin√©e. Historique:\n\n${getHistoryAsText()}\n\n R√©dige une conclusion appropri√©e et √©pique. R√©ponds en ${t('langCode')}.`;
            const finalResponse = await callGeminiAPI(finalPrompt);
            await addMessageToHistory({ name: t('conclusionTitle'), role: t('conclusionSystem'), icon: "üèÅ" }, finalResponse);
        }

        async function waitForUserChoice(choices, index) {
            return new Promise(resolve => {
                dom.choicesContainer.innerHTML = '';
                const wrapper = document.createElement('div');
                wrapper.className = 'choices-wrapper';

                choices.forEach(choiceText => {
                    const btn = document.createElement('button');
                    btn.className = 'choice-btn';
                    btn.textContent = choiceText;
                    btn.onclick = () => {
                        dom.choicesContainer.innerHTML = '';
                        resolve(choiceText);
                    };
                    wrapper.appendChild(btn);
                });
                dom.choicesContainer.appendChild(wrapper);

                const customActionContainer = document.createElement('div');
                customActionContainer.id = 'custom-action-container';
                customActionContainer.innerHTML = `
                    <input type="text" id="custom-action-input" class="input-group" placeholder="${t('customActionPlaceholder')}">
                    <button id="custom-action-btn" class="choice-btn">${t('sendButton')}</button>
                `;
                dom.choicesContainer.appendChild(customActionContainer);

                document.getElementById('custom-action-btn').onclick = () => {
                    const customText = document.getElementById('custom-action-input').value.trim();
                    if (customText) {
                        dom.choicesContainer.innerHTML = '';
                        resolve(customText);
                    }
                };
            });
        }
        
        async function rewindHistory(index) {
            currentSim.history.splice(index);
            currentSim.isFinished = false;
            loadSimulation(currentSim.id); 
            
            if (currentSim.mode === 'dreame') {
                await runDreameMode(index);
            }
        }

        async function callGeminiAPI(prompt) {
            dom.loader.style.display = 'block';
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.9, maxOutputTokens: 4096 }
                    })
                });
                if (!response.ok) throw new Error((await response.json()).error.message);
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                return `Erreur API: ${error.message}.`;
            } finally {
                dom.loader.style.display = 'none';
            }
        }

        function typewriterEffect(element, text) {
            return new Promise(resolve => {
                isTyping = true;
                let i = 0;
                function typing() {
                    if (i < text.length) {
                        element.innerHTML += text.charAt(i).replace(/\n/g, '<br>');
                        i++;
                        dom.conversationDiv.scrollTop = dom.conversationDiv.scrollHeight;
                        setTimeout(typing, 35);
                    } else {
                        isTyping = false;
                        resolve();
                    }
                }
                typing();
            });
        }

        async function displayMessage(message, index) {
            const { profile, text } = message;
            const messageEl = document.createElement('div');
            messageEl.className = 'message';
            if (profile.name === NARRATOR_PROFILE.name) messageEl.classList.add('narrator');
            if (profile.name === USER_PROFILE.name) messageEl.classList.add('user-choice');
            if (profile.name === CHAPTER_PROFILE.name) messageEl.classList.add('chapter-break');

            messageEl.innerHTML = `
                <div class="icon">${profile.icon}</div>
                <div class="content">
                    <strong>${profile.name === CHAPTER_PROFILE.name ? '' : profile.name} ${profile.role && profile.name !== CHAPTER_PROFILE.name ? `(${profile.role})` : ''}</strong>
                    <p>${profile.name === CHAPTER_PROFILE.name ? `--- ${text} ---` : ''}</p>
                </div>
            `;
            if (profile.name === USER_PROFILE.name && currentSim.mode === 'dreame') {
                const rewindBtn = document.createElement('button');
                rewindBtn.className = 'rewind-btn';
                rewindBtn.innerHTML = '&#8634;';
                rewindBtn.title = 'Modifier ce choix';
                rewindBtn.onclick = () => rewindHistory(index);
                messageEl.appendChild(rewindBtn);
            }
            dom.conversationDiv.appendChild(messageEl);
            const p = messageEl.querySelector('p');
            if (profile.name !== CHAPTER_PROFILE.name) {
                await typewriterEffect(p, text);
            }
        }
        
        function showSetupScreen() {
            dom.debateScreen.classList.add('hidden');
            dom.setupScreen.classList.remove('hidden');
            currentSim = null;
            renderSimulationsList();
        }

        function showDebateScreen() {
            dom.setupScreen.classList.add('hidden');
            dom.debateScreen.classList.remove('hidden');
            const title = currentSim.topic || currentSim.generatedTitle;
            const modeName = t(`mode${currentSim.mode.charAt(0).toUpperCase() + currentSim.mode.slice(1)}`);
            dom.debateTitle.textContent = `[${modeName}] ${title}`;
            dom.conversationDiv.innerHTML = '';
        }

        function loadSimulation(id) {
            const sim = savedSimulations.find(s => s.id === id);
            if (!sim) return;
            currentSim = sim;
            currentLanguage = sim.lang || 'fr'; // Load language from sim
            dom.languageSwitcher.value = currentLanguage;
            updateUIText();
            showDebateScreen();
            dom.conversationDiv.innerHTML = '';
            sim.history.forEach((msg, index) => {
                const messageEl = document.createElement('div');
                messageEl.className = 'message';
                if (msg.profile.name === NARRATOR_PROFILE.name) messageEl.classList.add('narrator');
                if (msg.profile.name === USER_PROFILE.name) messageEl.classList.add('user-choice');
                if (msg.profile.name === CHAPTER_PROFILE.name) messageEl.classList.add('chapter-break');
                messageEl.style.opacity = 1;
                messageEl.style.transform = 'none';
                messageEl.innerHTML = `
                    <div class="icon">${msg.profile.icon}</div>
                    <div class="content">
                        <strong>${msg.profile.name === CHAPTER_PROFILE.name ? '' : msg.profile.name} ${msg.profile.role && msg.profile.name !== CHAPTER_PROFILE.name ? `(${msg.profile.role})` : ''}</strong>
                        <p>${msg.profile.name === CHAPTER_PROFILE.name ? `--- ${msg.text} ---` : msg.text.replace(/\n/g, '<br>')}</p>
                    </div>`;
                if (msg.profile.name === USER_PROFILE.name && sim.mode === 'dreame' && !sim.isFinished) {
                    const rewindBtn = document.createElement('button');
                    rewindBtn.className = 'rewind-btn';
                    rewindBtn.innerHTML = '&#8634;';
                    rewindBtn.title = 'Modifier ce choix';
                    rewindBtn.onclick = () => rewindHistory(index);
                    messageEl.appendChild(rewindBtn);
                }
                dom.conversationDiv.appendChild(messageEl);
            });
            dom.choicesContainer.innerHTML = '';
            if (sim.isFinished) {
                dom.choicesContainer.innerHTML = `<p>${t('historyEnded')}</p>`;
            } else if (sim.mode === 'dreame' && !sim.isSpectator) {
                runDreameMode(sim.history.length);
            }
            renderSimulationsList();
        }
        
        function deleteSimulation(id, event) {
            event.stopPropagation();
            savedSimulations = savedSimulations.filter(s => s.id !== id);
            saveSimulationsToStorage();
            if (currentSim && currentSim.id === id) {
                showSetupScreen();
            }
            renderSimulationsList();
        }

        function saveSimulationsToStorage() {
            if (currentSim) {
                const index = savedSimulations.findIndex(s => s.id === currentSim.id);
                if (index !== -1) savedSimulations[index] = currentSim;
            }
            localStorage.setItem('iaSimulations', JSON.stringify(savedSimulations));
        }

        function loadSimulationsFromStorage() {
            const stored = localStorage.getItem('iaSimulations');
            savedSimulations = stored ? JSON.parse(stored) : [];
        }

        function renderSimulationsList() {
            dom.savedSimsList.innerHTML = '';
            savedSimulations.forEach(sim => {
                const li = document.createElement('li');
                li.dataset.id = sim.id;
                if (currentSim && sim.id === currentSim.id) li.classList.add('active');
                
                const textSpan = document.createElement('span');
                const modeName = translations[sim.lang || 'fr'][`mode${sim.mode.charAt(0).toUpperCase() + sim.mode.slice(1)}`];
                textSpan.textContent = `[${modeName}] ${sim.topic || sim.generatedTitle}`;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-sim-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => deleteSimulation(sim.id, e);
                
                li.appendChild(textSpan);
                li.appendChild(deleteBtn);
                li.onclick = () => loadSimulation(sim.id);
                dom.savedSimsList.appendChild(li);
            });
        }

        function getHistoryAsText() {
            return currentSim.history.map(msg => `${msg.profile.name}: ${msg.text}`).join('\n');
        }

        initialize();
    </script>
</body>
</ht
